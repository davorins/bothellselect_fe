{"ast":null,"code":"// utils/address.ts\n\nexport const parseAddress = addressString => {\n  // If it's already an Address object, return it as-is\n  if (typeof addressString !== 'string') {\n    return addressString;\n  }\n  if (!addressString) {\n    return {\n      street: '',\n      street2: '',\n      city: '',\n      state: '',\n      zip: ''\n    };\n  }\n\n  // Normalize the string by replacing multiple spaces with single space\n  const normalized = addressString.replace(/\\s+/g, ' ').trim();\n\n  // Split into parts and trim whitespace\n  const parts = normalized.split(',').map(part => part.trim());\n\n  // Initialize address object\n  const address = {\n    street: '',\n    street2: '',\n    city: '',\n    state: '',\n    zip: ''\n  };\n\n  // First part is always street\n  if (parts.length > 0) address.street = parts[0];\n\n  // Handle street2 if present (assuming it's the part before the last 3 parts)\n  if (parts.length > 3) {\n    address.street2 = parts.slice(1, -2).join(', ');\n  }\n\n  // City/state/zip handling\n  if (parts.length >= 3) {\n    // The city is typically the part before the last one\n    address.city = parts[parts.length - 2] || '';\n\n    // The last part should contain state and ZIP\n    const stateZipPart = parts[parts.length - 1].trim();\n\n    // Improved state/ZIP parsing\n    const stateZipMatch = stateZipPart.match(/([A-Za-z]{2})\\s*(\\d{5}(?:-\\d{4})?)/);\n    if (stateZipMatch) {\n      address.state = stateZipMatch[1].toUpperCase(); // Ensure uppercase state code\n      address.zip = stateZipMatch[2];\n    } else {\n      // Fallback - try to extract just the ZIP if state isn't found\n      const zipMatch = stateZipPart.match(/(\\d{5}(?:-\\d{4})?)/);\n      if (zipMatch) {\n        address.zip = zipMatch[0];\n      } else {\n        // If no ZIP found, put the whole thing in state (last resort)\n        address.state = stateZipPart;\n      }\n    }\n  }\n  return address;\n};\nexport const ensureAddress = address => {\n  if (!address) {\n    return {\n      street: '',\n      street2: '',\n      city: '',\n      state: '',\n      zip: ''\n    };\n  }\n  if (typeof address === 'string') {\n    return parseAddress(address);\n  }\n\n  // Handle case where street2 might be missing\n  return {\n    street: address.street || '',\n    street2: 'street2' in address ? address.street2 : '',\n    city: address.city || '',\n    state: address.state || '',\n    zip: address.zip || ''\n  };\n};\nexport const formatAddress = address => {\n  if (!address) return '';\n  const addr = typeof address === 'string' ? parseAddress(address) : address;\n  const parts = [addr.street, addr.street2, `${addr.city}, ${addr.state} ${addr.zip}`.trim()].filter(part => part && part.trim() !== '');\n  return parts.join(', ');\n};","map":{"version":3,"names":["parseAddress","addressString","street","street2","city","state","zip","normalized","replace","trim","parts","split","map","part","address","length","slice","join","stateZipPart","stateZipMatch","match","toUpperCase","zipMatch","ensureAddress","formatAddress","addr","filter"],"sources":["/Users/davorins/Desktop/bs/src/utils/address.ts"],"sourcesContent":["// utils/address.ts\n\nexport interface Address {\n  street: string;\n  street2: string;\n  city: string;\n  state: string;\n  zip: string;\n}\n\nexport const parseAddress = (addressString: string | Address): Address => {\n  // If it's already an Address object, return it as-is\n  if (typeof addressString !== 'string') {\n    return addressString as Address;\n  }\n\n  if (!addressString) {\n    return {\n      street: '',\n      street2: '',\n      city: '',\n      state: '',\n      zip: '',\n    };\n  }\n\n  // Normalize the string by replacing multiple spaces with single space\n  const normalized = addressString.replace(/\\s+/g, ' ').trim();\n\n  // Split into parts and trim whitespace\n  const parts = normalized.split(',').map((part) => part.trim());\n\n  // Initialize address object\n  const address: Address = {\n    street: '',\n    street2: '',\n    city: '',\n    state: '',\n    zip: '',\n  };\n\n  // First part is always street\n  if (parts.length > 0) address.street = parts[0];\n\n  // Handle street2 if present (assuming it's the part before the last 3 parts)\n  if (parts.length > 3) {\n    address.street2 = parts.slice(1, -2).join(', ');\n  }\n\n  // City/state/zip handling\n  if (parts.length >= 3) {\n    // The city is typically the part before the last one\n    address.city = parts[parts.length - 2] || '';\n\n    // The last part should contain state and ZIP\n    const stateZipPart = parts[parts.length - 1].trim();\n\n    // Improved state/ZIP parsing\n    const stateZipMatch = stateZipPart.match(\n      /([A-Za-z]{2})\\s*(\\d{5}(?:-\\d{4})?)/\n    );\n\n    if (stateZipMatch) {\n      address.state = stateZipMatch[1].toUpperCase(); // Ensure uppercase state code\n      address.zip = stateZipMatch[2];\n    } else {\n      // Fallback - try to extract just the ZIP if state isn't found\n      const zipMatch = stateZipPart.match(/(\\d{5}(?:-\\d{4})?)/);\n      if (zipMatch) {\n        address.zip = zipMatch[0];\n      } else {\n        // If no ZIP found, put the whole thing in state (last resort)\n        address.state = stateZipPart;\n      }\n    }\n  }\n\n  return address;\n};\n\nexport const ensureAddress = (\n  address:\n    | string\n    | Address\n    | { street: string; city: string; state: string; zip: string }\n    | undefined\n): Address => {\n  if (!address) {\n    return {\n      street: '',\n      street2: '',\n      city: '',\n      state: '',\n      zip: '',\n    };\n  }\n\n  if (typeof address === 'string') {\n    return parseAddress(address);\n  }\n\n  // Handle case where street2 might be missing\n  return {\n    street: address.street || '',\n    street2: 'street2' in address ? address.street2 : '',\n    city: address.city || '',\n    state: address.state || '',\n    zip: address.zip || '',\n  };\n};\n\nexport const formatAddress = (address: string | Address): string => {\n  if (!address) return '';\n\n  const addr = typeof address === 'string' ? parseAddress(address) : address;\n\n  const parts = [\n    addr.street,\n    addr.street2,\n    `${addr.city}, ${addr.state} ${addr.zip}`.trim(),\n  ].filter((part) => part && part.trim() !== '');\n\n  return parts.join(', ');\n};\n"],"mappings":"AAAA;;AAUA,OAAO,MAAMA,YAAY,GAAIC,aAA+B,IAAc;EACxE;EACA,IAAI,OAAOA,aAAa,KAAK,QAAQ,EAAE;IACrC,OAAOA,aAAa;EACtB;EAEA,IAAI,CAACA,aAAa,EAAE;IAClB,OAAO;MACLC,MAAM,EAAE,EAAE;MACVC,OAAO,EAAE,EAAE;MACXC,IAAI,EAAE,EAAE;MACRC,KAAK,EAAE,EAAE;MACTC,GAAG,EAAE;IACP,CAAC;EACH;;EAEA;EACA,MAAMC,UAAU,GAAGN,aAAa,CAACO,OAAO,CAAC,MAAM,EAAE,GAAG,CAAC,CAACC,IAAI,CAAC,CAAC;;EAE5D;EACA,MAAMC,KAAK,GAAGH,UAAU,CAACI,KAAK,CAAC,GAAG,CAAC,CAACC,GAAG,CAAEC,IAAI,IAAKA,IAAI,CAACJ,IAAI,CAAC,CAAC,CAAC;;EAE9D;EACA,MAAMK,OAAgB,GAAG;IACvBZ,MAAM,EAAE,EAAE;IACVC,OAAO,EAAE,EAAE;IACXC,IAAI,EAAE,EAAE;IACRC,KAAK,EAAE,EAAE;IACTC,GAAG,EAAE;EACP,CAAC;;EAED;EACA,IAAII,KAAK,CAACK,MAAM,GAAG,CAAC,EAAED,OAAO,CAACZ,MAAM,GAAGQ,KAAK,CAAC,CAAC,CAAC;;EAE/C;EACA,IAAIA,KAAK,CAACK,MAAM,GAAG,CAAC,EAAE;IACpBD,OAAO,CAACX,OAAO,GAAGO,KAAK,CAACM,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAACC,IAAI,CAAC,IAAI,CAAC;EACjD;;EAEA;EACA,IAAIP,KAAK,CAACK,MAAM,IAAI,CAAC,EAAE;IACrB;IACAD,OAAO,CAACV,IAAI,GAAGM,KAAK,CAACA,KAAK,CAACK,MAAM,GAAG,CAAC,CAAC,IAAI,EAAE;;IAE5C;IACA,MAAMG,YAAY,GAAGR,KAAK,CAACA,KAAK,CAACK,MAAM,GAAG,CAAC,CAAC,CAACN,IAAI,CAAC,CAAC;;IAEnD;IACA,MAAMU,aAAa,GAAGD,YAAY,CAACE,KAAK,CACtC,oCACF,CAAC;IAED,IAAID,aAAa,EAAE;MACjBL,OAAO,CAACT,KAAK,GAAGc,aAAa,CAAC,CAAC,CAAC,CAACE,WAAW,CAAC,CAAC,CAAC,CAAC;MAChDP,OAAO,CAACR,GAAG,GAAGa,aAAa,CAAC,CAAC,CAAC;IAChC,CAAC,MAAM;MACL;MACA,MAAMG,QAAQ,GAAGJ,YAAY,CAACE,KAAK,CAAC,oBAAoB,CAAC;MACzD,IAAIE,QAAQ,EAAE;QACZR,OAAO,CAACR,GAAG,GAAGgB,QAAQ,CAAC,CAAC,CAAC;MAC3B,CAAC,MAAM;QACL;QACAR,OAAO,CAACT,KAAK,GAAGa,YAAY;MAC9B;IACF;EACF;EAEA,OAAOJ,OAAO;AAChB,CAAC;AAED,OAAO,MAAMS,aAAa,GACxBT,OAIa,IACD;EACZ,IAAI,CAACA,OAAO,EAAE;IACZ,OAAO;MACLZ,MAAM,EAAE,EAAE;MACVC,OAAO,EAAE,EAAE;MACXC,IAAI,EAAE,EAAE;MACRC,KAAK,EAAE,EAAE;MACTC,GAAG,EAAE;IACP,CAAC;EACH;EAEA,IAAI,OAAOQ,OAAO,KAAK,QAAQ,EAAE;IAC/B,OAAOd,YAAY,CAACc,OAAO,CAAC;EAC9B;;EAEA;EACA,OAAO;IACLZ,MAAM,EAAEY,OAAO,CAACZ,MAAM,IAAI,EAAE;IAC5BC,OAAO,EAAE,SAAS,IAAIW,OAAO,GAAGA,OAAO,CAACX,OAAO,GAAG,EAAE;IACpDC,IAAI,EAAEU,OAAO,CAACV,IAAI,IAAI,EAAE;IACxBC,KAAK,EAAES,OAAO,CAACT,KAAK,IAAI,EAAE;IAC1BC,GAAG,EAAEQ,OAAO,CAACR,GAAG,IAAI;EACtB,CAAC;AACH,CAAC;AAED,OAAO,MAAMkB,aAAa,GAAIV,OAAyB,IAAa;EAClE,IAAI,CAACA,OAAO,EAAE,OAAO,EAAE;EAEvB,MAAMW,IAAI,GAAG,OAAOX,OAAO,KAAK,QAAQ,GAAGd,YAAY,CAACc,OAAO,CAAC,GAAGA,OAAO;EAE1E,MAAMJ,KAAK,GAAG,CACZe,IAAI,CAACvB,MAAM,EACXuB,IAAI,CAACtB,OAAO,EACZ,GAAGsB,IAAI,CAACrB,IAAI,KAAKqB,IAAI,CAACpB,KAAK,IAAIoB,IAAI,CAACnB,GAAG,EAAE,CAACG,IAAI,CAAC,CAAC,CACjD,CAACiB,MAAM,CAAEb,IAAI,IAAKA,IAAI,IAAIA,IAAI,CAACJ,IAAI,CAAC,CAAC,KAAK,EAAE,CAAC;EAE9C,OAAOC,KAAK,CAACO,IAAI,CAAC,IAAI,CAAC;AACzB,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}